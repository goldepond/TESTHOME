# 매물 관리 프로세스 상세 분석

## 🏠 매물 관리 전체 흐름

### 1. 매물 저장 단계 (HomePage)

#### 1.1 매물 저장 함수 (lib/screens/home_page.dart 라인 120-160)
```dart
// 등기부등본 정보를 데이터베이스에 저장
Future<void> saveRegisterDataToDatabase() async {
  setState(() {
    isSaving = true;                                   // 저장 중 상태 시작
    saveMessage = null;                                // 메시지 초기화
  });

  try {
    // 1. Property 객체 생성
    final property = Property(
      address: fullAddress,                            // 전체 주소
      transactionType: '매매',                         // 거래 유형 (기본값: 매매)
      price: 0,                                        // 가격 (나중에 입력)
      description: '등기부등본 조회를 통해 등록된 매물',  // 설명
      registerData: json.encode(registerResult),       // 등기부등본 원본 JSON
      registerSummary: json.encode(registerResult),    // 요약 정보 (현재는 동일)
      contractStatus: '대기',                          // 계약 상태 (기본값: 대기)
      mainContractor: widget.userName,                 // 대표 계약자 (로그인 사용자)
      contractor: widget.userName,                     // 계약자 (로그인 사용자)
    );

    // 2. 메모리에 Property 객체 추가 (현재는 데이터베이스 미사용)
    _addProperty(property);

    setState(() {
      saveMessage = '✅ 매물이 성공적으로 등록되었습니다!';  // 성공 메시지
    });

    // 3. 3초 후 메시지 자동 제거
    Future.delayed(const Duration(seconds: 3), () {
      if (mounted) {
        setState(() {
          saveMessage = null;
        });
      }
    });

  } catch (e) {
    setState(() {
      saveMessage = '❌ 매물 등록 중 오류가 발생했습니다: $e';  // 에러 메시지
    });
  } finally {
    setState(() {
      isSaving = false;                                // 저장 중 상태 종료
    });
  }
}
```

#### 1.2 Property 객체 메모리 저장 (lib/screens/home_page.dart 라인 50-55)
```dart
// Property 객체를 메모리에 추가 (현재는 데이터베이스 미사용)
void _addProperty(Property property) {
  setState(() {
    properties.add(property);                          // 메모리 리스트에 추가
  });
  print('매물이 메모리에 추가되었습니다: ${property.address}');  // 디버그 로그
}
```

#### 1.3 Property 모델 구조 (lib/models/property.dart 라인 1-35)
```dart
// 부동산 데이터 모델
class Property {
  final int? id;                    // SQLite database ID (AUTO INCREMENT) - 현재 미사용
  final String address;             // 부동산 주소 (전체 주소)
  final String transactionType;     // 거래 유형 (매매, 전세, 월세)
  final int price;                  // 가격 (원 단위)
  final String description;         // 매물 설명
  final String registerData;        // JSON 문자열로 저장된 등기부등본 데이터
  final String registerSummary;     // 핵심 정보만 담은 JSON (현재는 원본과 동일)
  final String contractStatus;      // 계약 상태 (대기, 진행중, 완료, 취소)
  final String mainContractor;      // 대표 계약자 (로그인 사용자)
  final String contractor;          // 계약자 (한글/영문 이름)
  final DateTime createdAt;         // 생성일 (자동 설정)

  // 생성자
  Property({
    this.id,                        // ID는 선택적 (새 매물 생성 시 null)
    required this.address,          // 주소는 필수
    required this.transactionType,  // 거래 유형은 필수
    required this.price,            // 가격은 필수
    String? description,            // 설명은 선택적 (기본값: 빈 문자열)
    String? registerData,           // 등기부등본 데이터는 선택적 (기본값: 빈 JSON)
    String? registerSummary,        // 요약 정보는 선택적 (기본값: 빈 문자열)
    String? contractStatus,         // 계약 상태는 선택적 (기본값: '대기')
    String? mainContractor,         // 대표 계약자는 선택적 (기본값: 빈 문자열)
    String? contractor,             // 계약자는 선택적 (기본값: 빈 문자열)
    DateTime? createdAt,            // 생성일은 선택적 (기본값: 현재 시간)
  })  : description = description ?? '',                    // null 체크 및 기본값 설정
        registerData = registerData ?? '{}',                // 빈 JSON 객체
        registerSummary = registerSummary ?? '',            // 빈 문자열
        contractStatus = contractStatus ?? '대기',          // 기본 상태: 대기
        mainContractor = mainContractor ?? '',              // 빈 문자열
        contractor = contractor ?? '',                      // 빈 문자열
        createdAt = createdAt ?? DateTime.now();            // 현재 시간
}
```

### 2. 매물 목록 표시 단계 (HouseMarketPage)

#### 2.1 매물 목록 화면 구조 (lib/main.dart 라인 350-450)
```dart
class _HouseMarketPageState extends State<HouseMarketPage> {
  List<Property> properties = [];                       // 매물 목록 (메모리 저장)
  final List<String> houseImages = [                    // 매물 이미지 목록
    'assets/sample_house.jpg',
    'assets/sample_house2.jpg',
    'assets/sample_house3.jpg',
  ];

  @override
  Widget build(BuildContext context) {
    return properties.isEmpty
        ? Center(child: Text('등록된 매물이 없습니다.'))    // 매물이 없을 때 메시지
        : ListView.builder(                              // 매물 목록 표시
            itemCount: properties.length,
            itemBuilder: (context, index) {
              final property = properties[index];        // 현재 매물
              final imgPath = houseImages[index % houseImages.length];  // 순환 이미지
              
              // total_amount 파싱 (등기부등본에서 가격 정보 추출)
              int? totalAmount;
              try {
                final regData = property.registerData;
                if (regData.isNotEmpty && regData != '{}') {
                  final map = json.decode(regData);
                  if (map['total_amount'] != null) {
                    totalAmount = int.tryParse(map['total_amount'].toString().replaceAll(',', ''));
                  }
                }
              } catch (_) {
                // 파싱 실패 시 무시
              }
              
              // 매물 카드 반환
              return Card(
                child: Column(
                  children: [
                    // 매물 이미지
                    Image.asset(
                      imgPath, 
                      height: 160, 
                      fit: BoxFit.cover
                    ),
                    // 매물 주소
                    Text(
                      property.address, 
                      style: TextStyle(
                        fontSize: 18, 
                        fontWeight: FontWeight.bold
                      )
                    ),
                    // 거래 유형
                    Text('거래유형: ${property.transactionType}'),
                    // 가격 정보 (있는 경우만 표시)
                    if (totalAmount != null)
                      Text(
                        '가격: ${totalAmount.toString().replaceAllMapped(
                          RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))'), 
                          (Match m) => '${m[1]},'
                        )}원'
                      ),
                  ],
                ),
              );
            },
          );
  }
}
```

#### 2.2 매물 카드 상세 구조
```dart
// 매물 카드 위젯 (개선된 버전)
Widget _buildPropertyCard(Property property, int index) {
  final imgPath = houseImages[index % houseImages.length];
  
  // 등기부등본에서 가격 정보 파싱
  int? totalAmount;
  String? propertyType;
  String? propertyArea;
  
  try {
    final regData = property.registerData;
    if (regData.isNotEmpty && regData != '{}') {
      final map = json.decode(regData);
      
      // 가격 정보 추출
      if (map['total_amount'] != null) {
        totalAmount = int.tryParse(map['total_amount'].toString().replaceAll(',', ''));
      }
      
      // 부동산 정보 추출 (CurrentStateParser 사용)
      final rawJson = json.encode(map);
      final currentState = parseCurrentState(rawJson);
      propertyType = currentState.building.structure;
      propertyArea = currentState.building.areaTotal;
    }
  } catch (e) {
    print('매물 정보 파싱 오류: $e');
  }
  
  return Card(
    margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
    elevation: 4,
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 이미지 섹션
        Stack(
          children: [
            Image.asset(
              imgPath,
              height: 200,
              width: double.infinity,
              fit: BoxFit.cover,
            ),
            // 계약 상태 배지
            Positioned(
              top: 8,
              right: 8,
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: _getStatusColor(property.contractStatus),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  property.contractStatus,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ],
        ),
        
        // 정보 섹션
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // 주소
              Text(
                property.address,
                style: const TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              
              const SizedBox(height: 8),
              
              // 거래 유형
              Row(
                children: [
                  Icon(Icons.category, size: 16, color: Colors.grey[600]),
                  const SizedBox(width: 4),
                  Text(
                    '거래유형: ${property.transactionType}',
                    style: TextStyle(color: Colors.grey[600]),
                  ),
                ],
              ),
              
              // 건물 정보 (있는 경우)
              if (propertyType != null) ...[
                const SizedBox(height: 4),
                Row(
                  children: [
                    Icon(Icons.home, size: 16, color: Colors.grey[600]),
                    const SizedBox(width: 4),
                    Text(
                      '구조: $propertyType',
                      style: TextStyle(color: Colors.grey[600]),
                    ),
                  ],
                ),
              ],
              
              // 면적 정보 (있는 경우)
              if (propertyArea != null) ...[
                const SizedBox(height: 4),
                Row(
                  children: [
                    Icon(Icons.square_foot, size: 16, color: Colors.grey[600]),
                    const SizedBox(width: 4),
                    Text(
                      '면적: $propertyArea',
                      style: TextStyle(color: Colors.grey[600]),
                    ),
                  ],
                ),
              ],
              
              // 가격 정보 (있는 경우)
              if (totalAmount != null) ...[
                const SizedBox(height: 8),
                Text(
                  '가격: ${totalAmount.toString().replaceAllMapped(
                    RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))'),
                    (Match m) => '${m[1]},'
                  )}원',
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: AppColors.kBrown,
                  ),
                ),
              ],
              
              // 등록일
              const SizedBox(height: 8),
              Text(
                '등록일: ${property.createdAt.toString().substring(0, 10)}',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey[500],
                ),
              ),
            ],
          ),
        ),
      ],
    ),
  );
}
```

#### 2.3 계약 상태 색상 함수
```dart
// 계약 상태에 따른 색상 반환
Color _getStatusColor(String status) {
  switch (status) {
    case '대기':
      return Colors.orange;
    case '진행중':
      return Colors.blue;
    case '완료':
      return Colors.green;
    case '취소':
      return Colors.red;
    default:
      return Colors.grey;
  }
}
```

### 3. 계약 관리 화면 (ContractManagementScreen)

#### 3.1 계약 관리 화면 구조 (lib/screens/contract_management_screen.dart 라인 1-50)
```dart
class ContractManagementScreen extends StatefulWidget {
  final String userName;                              // 사용자 이름
  const ContractManagementScreen({Key? key, required this.userName});
}

class _ContractManagementScreenState extends State<ContractManagementScreen> {
  List<Property> myProperties = [];                    // 내 매물 목록
  bool isLoading = false;                             // 로딩 상태

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('계약 관리'),
        backgroundColor: AppColors.kBrown,
        foregroundColor: Colors.white,
      ),
      body: isLoading
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // 계약서 정보 섹션
                  _buildHouseLeaseAgreementInfo(),
                  const SizedBox(height: 20),
                  
                  // 구매 계약서 관리 섹션
                  _buildLeftSection(),
                  const SizedBox(height: 20),
                  
                  // 판매 매물 계약서 관리 섹션
                  _buildRightSection(),
                ],
              ),
            ),
    );
  }
}
```

#### 3.2 계약서 정보 표시 (lib/screens/contract_management_screen.dart 라인 20-50)
```dart
// 주택임대차계약서 정보 표시
Widget _buildHouseLeaseAgreementInfo() {
  return Container(
    padding: const EdgeInsets.all(16),
    decoration: BoxDecoration(
      color: AppColors.kLightBrown,
      borderRadius: BorderRadius.circular(12),
      border: Border.all(color: AppColors.kBrown, width: 1),
    ),
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(Icons.description, color: AppColors.kBrown),
            const SizedBox(width: 8),
            const Text(
              '주택임대차계약서',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
                color: AppColors.kBrown,
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        Text(
          '• 임대차계약서 작성 및 관리\n'
          '• 등기부등본 기반 자동 입력\n'
          '• 계약 상태 추적\n'
          '• PDF 생성 및 다운로드',
          style: TextStyle(
            fontSize: 14,
            color: Colors.grey[700],
            height: 1.5,
          ),
        ),
      ],
    ),
  );
}
```

#### 3.3 구매 계약서 관리 섹션 (lib/screens/contract_management_screen.dart 라인 80-150)
```dart
// 구매 계약서 관리 섹션 (왼쪽)
Widget _buildLeftSection() {
  return Container(
    width: double.infinity,
    padding: const EdgeInsets.all(16),
    decoration: BoxDecoration(
      color: Colors.white,
      borderRadius: BorderRadius.circular(12),
      border: Border.all(color: Colors.grey[300]!),
      boxShadow: [
        BoxShadow(
          color: Colors.grey.withOpacity(0.1),
          spreadRadius: 1,
          blurRadius: 3,
          offset: const Offset(0, 2),
        ),
      ],
    ),
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(Icons.shopping_cart, color: AppColors.kBrown),
            const SizedBox(width: 8),
            const Text(
              '구매 계약서 관리',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
                color: AppColors.kBrown,
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        
        // 구매 매물 목록
        if (myProperties.isEmpty)
          const Center(
            child: Padding(
              padding: EdgeInsets.all(20),
              child: Text(
                '구매한 매물이 없습니다.',
                style: TextStyle(
                  color: Colors.grey,
                  fontSize: 16,
                ),
              ),
            ),
          )
        else
          ...myProperties
              .where((property) => property.transactionType == '매매')
              .map((property) => _buildPropertyContractCard(property, '구매')),
      ],
    ),
  );
}
```

#### 3.4 판매 매물 계약서 관리 섹션 (lib/screens/contract_management_screen.dart 라인 155-250)
```dart
// 판매 매물 계약서 관리 섹션 (오른쪽)
Widget _buildRightSection() {
  return Container(
    width: double.infinity,
    padding: const EdgeInsets.all(16),
    decoration: BoxDecoration(
      color: Colors.white,
      borderRadius: BorderRadius.circular(12),
      border: Border.all(color: Colors.grey[300]!),
      boxShadow: [
        BoxShadow(
          color: Colors.grey.withOpacity(0.1),
          spreadRadius: 1,
          blurRadius: 3,
          offset: const Offset(0, 2),
        ),
      ],
    ),
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(Icons.sell, color: AppColors.kBrown),
            const SizedBox(width: 8),
            const Text(
              '판매 매물 계약서 관리',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
                color: AppColors.kBrown,
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        
        // 판매 매물 목록
        if (myProperties.isEmpty)
          const Center(
            child: Padding(
              padding: EdgeInsets.all(20),
              child: Text(
                '판매한 매물이 없습니다.',
                style: TextStyle(
                  color: Colors.grey,
                  fontSize: 16,
                ),
              ),
            ),
          )
        else
          ...myProperties
              .where((property) => property.transactionType == '매매')
              .map((property) => _buildPropertyContractCard(property, '판매')),
      ],
    ),
  );
}
```

#### 3.5 매물 계약서 카드 (lib/screens/contract_management_screen.dart 라인 250-350)
```dart
// 매물 계약서 카드 위젯
Widget _buildPropertyContractCard(Property property, String type) {
  return Card(
    margin: const EdgeInsets.only(bottom: 12),
    child: Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // 매물 정보 헤더
          Row(
            children: [
              Expanded(
                child: Text(
                  property.address,
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: _getStatusColor(property.contractStatus),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  property.contractStatus,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 8),
          
          // 매물 상세 정보
          Text('거래유형: ${property.transactionType}'),
          Text('계약자: ${property.contractor}'),
          Text('등록일: ${property.createdAt.toString().substring(0, 10)}'),
          
          const SizedBox(height: 12),
          
          // 액션 버튼들
          Row(
            children: [
              // 계약서 보기 버튼
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: () => _viewContract(property),
                  icon: const Icon(Icons.visibility, size: 16),
                  label: const Text('계약서 보기'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.kBrown,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 8),
                  ),
                ),
              ),
              const SizedBox(width: 8),
              // 계약서 수정 버튼
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: () => _editContract(property),
                  icon: const Icon(Icons.edit, size: 16),
                  label: const Text('수정'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.orange,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 8),
                  ),
                ),
              ),
              const SizedBox(width: 8),
              // 계약서 삭제 버튼
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: () => _deleteContract(property),
                  icon: const Icon(Icons.delete, size: 16),
                  label: const Text('삭제'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.red,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 8),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    ),
  );
}
```

### 4. 매물 데이터 변환 및 저장

#### 4.1 Property 모델 변환 메서드 (lib/models/property.dart 라인 35-75)
```dart
// Property 객체를 Map으로 변환 (데이터베이스 저장용)
Map<String, dynamic> toMap() {
  return {
    'id': id,                                          // ID (null이면 AUTO INCREMENT)
    'address': address,                                // 주소
    'transactionType': transactionType,                // 거래 유형
    'price': price,                                    // 가격
    'description': description,                        // 설명
    'registerData': registerData,                      // 등기부등본 JSON
    'registerSummary': registerSummary,                // 요약 정보
    'contractStatus': contractStatus,                  // 계약 상태
    'mainContractor': mainContractor,                  // 대표 계약자
    'contractor': contractor,                          // 계약자
    'createdAt': createdAt.toIso8601String(),          // 생성일 (ISO 문자열)
  };
}

// Map에서 Property 객체 생성 (데이터베이스 로드용)
factory Property.fromMap(Map<String, dynamic> map) {
  return Property(
    id: map['id'] as int?,                             // ID
    address: map['address'] as String,                 // 주소
    transactionType: map['transactionType'] as String, // 거래 유형
    price: map['price'] as int,                        // 가격
    description: map['description'] as String? ?? '',  // 설명
    registerData: map['registerData'] as String? ?? '{}', // 등기부등본 JSON
    registerSummary: map['registerSummary'] as String? ?? '', // 요약 정보
    contractStatus: map['contractStatus'] as String? ?? '대기', // 계약 상태
    mainContractor: map['mainContractor'] as String? ?? '', // 대표 계약자
    contractor: map['contractor'] as String? ?? '',    // 계약자
    createdAt: map['createdAt'] != null 
        ? DateTime.parse(map['createdAt'] as String)   // 생성일 파싱
        : DateTime.now(),                              // 기본값: 현재 시간
  );
}
```

#### 4.2 Property 객체 복사 메서드 (lib/models/property.dart 라인 77-103)
```dart
// Property 객체 복사 (일부 필드만 변경)
Property copyWith({
  int? id,                                             // ID 변경
  String? address,                                     // 주소 변경
  String? transactionType,                             // 거래 유형 변경
  int? price,                                          // 가격 변경
  String? description,                                 // 설명 변경
  String? registerData,                                // 등기부등본 데이터 변경
  String? registerSummary,                             // 요약 정보 변경
  String? contractStatus,                              // 계약 상태 변경
  String? mainContractor,                              // 대표 계약자 변경
  String? contractor,                                  // 계약자 변경
  DateTime? createdAt,                                 // 생성일 변경
}) {
  return Property(
    id: id ?? this.id,                                 // 변경되지 않으면 기존 값 유지
    address: address ?? this.address,
    transactionType: transactionType ?? this.transactionType,
    price: price ?? this.price,
    description: description ?? this.description,
    registerData: registerData ?? this.registerData,
    registerSummary: registerSummary ?? this.registerSummary,
    contractStatus: contractStatus ?? this.contractStatus,
    mainContractor: mainContractor ?? this.mainContractor,
    contractor: contractor ?? this.contractor,
    createdAt: createdAt ?? this.createdAt,
  );
}
```

### 5. 매물 관리 액션 함수들

#### 5.1 계약서 보기 함수 (lib/screens/contract_management_screen.dart 라인 350-370)
```dart
// 계약서 보기 함수
void _viewContract(Property property) {
  try {
    // 등기부등본 데이터 파싱
    final registerData = json.decode(property.registerData);
    
    // 계약서 작성 화면으로 이동 (읽기 전용)
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => ContractInputFormScreen(
          initialData: registerData,                   // 등기부등본 데이터
          userName: widget.userName,                   // 사용자 이름
          property: property,                          // Property 객체
        ),
      ),
    );
  } catch (e) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('계약서 보기 중 오류: $e'),
        backgroundColor: Colors.red,
      ),
    );
  }
}
```

#### 5.2 계약서 수정 함수 (lib/screens/contract_management_screen.dart 라인 370-390)
```dart
// 계약서 수정 함수
void _editContract(Property property) {
  try {
    // 등기부등본 데이터 파싱
    final registerData = json.decode(property.registerData);
    
    // 계약서 작성 화면으로 이동 (수정 모드)
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => ContractInputFormScreen(
          initialData: registerData,                   // 등기부등본 데이터
          userName: widget.userName,                   // 사용자 이름
          property: property,                          // Property 객체
        ),
      ),
    ).then((result) {
      // 수정 완료 후 목록 새로고침
      if (result != null) {
        setState(() {
          // 실제로는 데이터베이스 업데이트 필요
          print('계약서 수정 완료: $result');
        });
      }
    });
  } catch (e) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('계약서 수정 중 오류: $e'),
        backgroundColor: Colors.red,
      ),
    );
  }
}
```

#### 5.3 계약서 삭제 함수 (lib/screens/contract_management_screen.dart 라인 390-420)
```dart
// 계약서 삭제 함수
void _deleteContract(Property property) {
  // 삭제 확인 다이얼로그
  showDialog(
    context: context,
    builder: (BuildContext context) {
      return AlertDialog(
        title: const Text('계약서 삭제'),
        content: Text('정말로 "${property.address}" 매물의 계약서를 삭제하시겠습니까?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('취소'),
          ),
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              _confirmDelete(property);
            },
            child: const Text('삭제', style: TextStyle(color: Colors.red)),
          ),
        ],
      );
    },
  );
}

// 삭제 확인 실행
void _confirmDelete(Property property) {
  try {
    setState(() {
      // 실제로는 데이터베이스에서 삭제 필요
      myProperties.removeWhere((p) => p.id == property.id);
    });
    
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('계약서가 삭제되었습니다.'),
        backgroundColor: Colors.green,
      ),
    );
  } catch (e) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('계약서 삭제 중 오류: $e'),
        backgroundColor: Colors.red,
      ),
    );
  }
}
```

### 6. 데이터베이스 연동 (현재 미사용)

#### 6.1 DatabaseHelper 구조 (lib/database/database_helper.dart)
```dart
// SQLite 데이터베이스 헬퍼 (현재 미사용)
class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;
  DatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('property.db');
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    return await openDatabase(
      path,
      version: 1,
      onCreate: _createDB,
    );
  }

  Future<void> _createDB(Database db, int version) async {
    // Property 테이블 생성
    await db.execute('''
      CREATE TABLE properties (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        address TEXT NOT NULL,
        transactionType TEXT NOT NULL,
        price INTEGER NOT NULL,
        description TEXT,
        registerData TEXT,
        registerSummary TEXT,
        contractStatus TEXT,
        mainContractor TEXT,
        contractor TEXT,
        createdAt TEXT NOT NULL
      )
    ''');
  }

  // Property 삽입
  Future<int> insertProperty(Property property) async {
    final db = await database;
    return await db.insert('properties', property.toMap());
  }

  // Property 조회
  Future<List<Property>> getAllProperties() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query('properties');
    return List.generate(maps.length, (i) => Property.fromMap(maps[i]));
  }

  // Property 업데이트
  Future<int> updateProperty(Property property) async {
    final db = await database;
    return await db.update(
      'properties',
      property.toMap(),
      where: 'id = ?',
      whereArgs: [property.id],
    );
  }

  // Property 삭제
  Future<int> deleteProperty(int id) async {
    final db = await database;
    return await db.delete(
      'properties',
      where: 'id = ?',
      whereArgs: [id],
    );
  }
}
```

### 7. 성능 최적화 및 개선사항

#### 7.1 현재 구현의 장점
1. **메모리 기반**: 빠른 접근 및 수정
2. **등기부등본 연동**: 자동 데이터 입력
3. **상태 관리**: 계약 상태 추적
4. **이미지 순환**: 매물 이미지 자동 할당

#### 7.2 개선 가능한 부분
1. **데이터베이스 연동**: SQLite 또는 Firebase Firestore
2. **이미지 업로드**: 실제 매물 이미지 업로드
3. **검색 기능**: 주소, 가격, 유형별 검색
4. **필터링**: 상태, 날짜별 필터링
5. **정렬**: 가격, 등록일별 정렬
6. **페이지네이션**: 대량 데이터 처리
7. **동기화**: 클라우드 동기화

### 8. 실제 사용 예시

#### 8.1 정상적인 매물 관리 흐름
```
1. 등기부등본 조회 성공
2. "판매 등록 심사" 버튼 클릭
3. Property 객체 생성 및 메모리 저장
4. "내집사기" 탭에서 매물 목록 확인
5. "계약관리" 탭에서 계약서 관리
6. 계약서 보기/수정/삭제 기능 사용
```

#### 8.2 에러 상황 처리
```
1. 매물 등록 실패: "❌ 매물 등록 중 오류가 발생했습니다"
2. 계약서 보기 실패: "계약서 보기 중 오류"
3. 계약서 수정 실패: "계약서 수정 중 오류"
4. 계약서 삭제 실패: "계약서 삭제 중 오류"
5. 데이터 파싱 실패: 기본값으로 처리
```

이 매물 관리 프로세스는 등기부등본 데이터를 기반으로 한 매물 등록부터 목록 표시, 계약서 관리, 상태 추적까지 모든 단계를 체계적으로 처리하며, 사용자 친화적인 인터페이스와 견고한 데이터 관리를 제공합니다. 